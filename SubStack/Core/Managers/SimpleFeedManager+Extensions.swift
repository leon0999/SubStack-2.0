// Core/Managers/SimpleFeedManager+Extensions.swift
import Foundation
import SwiftUI

// MARK: - SimpleFeedManager Extensions
extension SimpleFeedManager {

    // MARK: - Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
    private static var updateTimer: Timer?

    /// Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë (5Î∂ÑÎßàÎã§)
    func startRealtimeUpdates() {
        // Í∏∞Ï°¥ ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
        stopRealtimeUpdates()

        // Î©îÏù∏ Ïä§Î†àÎìúÏóêÏÑú ÌÉÄÏù¥Î®∏ Ïã§Ìñâ
        DispatchQueue.main.async {
            Self.updateTimer = Timer.scheduledTimer(withTimeInterval: 300, repeats: true) { _ in
                Task {
                    await self.refreshAllFeeds()
                    print("üîÑ Ïã§ÏãúÍ∞Ñ ÌîºÎìú ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å")
                }
            }

            // Ï¶âÏãú Ìïú Î≤à Ïã§Ìñâ
            Task {
                await self.refreshAllFeeds()
            }
        }

        print("‚è∞ Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûëÎê® (5Î∂Ñ Í∞ÑÍ≤©)")
    }

    /// Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄ
    func stopRealtimeUpdates() {
        Self.updateTimer?.invalidate()
        Self.updateTimer = nil
        print("‚èπ Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄÎê®")
    }

    // MARK: - ÌïÑÌÑ∞ÎßÅ Í∏∞Îä•

    /// ÏÑúÎπÑÏä§Î≥Ñ ÌïÑÌÑ∞ÎßÅ
    func filterByService(_ service: String) -> [ServiceUpdate] {
        if service == "Ï†ÑÏ≤¥" {
            return updates
        }
        return updates.filter { $0.service == service }
    }

    /// Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÌïÑÌÑ∞ÎßÅ
    func filterByCategory(_ category: ServiceUpdate.UpdateCategory) -> [ServiceUpdate] {
        return updates.filter { $0.category == category }
    }

    /// Ï§ëÏöîÎèÑÎ≥Ñ ÌïÑÌÑ∞ÎßÅ
    func filterByImportance(_ importance: ServiceUpdate.UpdateImportance) -> [ServiceUpdate] {
        return updates.filter { $0.importance == importance }
    }

    /// ÏùΩÏßÄ ÏïäÏùÄ ÏóÖÎç∞Ïù¥Ìä∏Îßå ÌïÑÌÑ∞ÎßÅ
    func unreadUpdates() -> [ServiceUpdate] {
        return updates.filter { !$0.isRead }
    }

    /// ÎÇ†Ïßú Î≤îÏúÑÎ°ú ÌïÑÌÑ∞ÎßÅ
    func filterByDateRange(from startDate: Date, to endDate: Date) -> [ServiceUpdate] {
        return updates.filter { update in
            update.publishedDate >= startDate && update.publishedDate <= endDate
        }
    }

    /// Î≥µÌï© ÌïÑÌÑ∞ÎßÅ
    func filterUpdates(
        service: String? = nil,
        category: ServiceUpdate.UpdateCategory? = nil,
        importance: ServiceUpdate.UpdateImportance? = nil,
        unreadOnly: Bool = false
    ) -> [ServiceUpdate] {
        var filtered = updates

        if let service = service, service != "Ï†ÑÏ≤¥" {
            filtered = filtered.filter { $0.service == service }
        }

        if let category = category {
            filtered = filtered.filter { $0.category == category }
        }

        if let importance = importance {
            filtered = filtered.filter { $0.importance == importance }
        }

        if unreadOnly {
            filtered = filtered.filter { !$0.isRead }
        }

        return filtered
    }

    // MARK: - ÏÜåÏÖú ÎØ∏ÎîîÏñ¥ ÌÜµÌï© (Phase 3)

    /// ÏÜåÏÖú ÎØ∏ÎîîÏñ¥ Ïª®ÌÖêÏ∏† Í∞ÄÏ†∏Ïò§Í∏∞
    func fetchSocialContent() async {
        print("üåê ÏÜåÏÖú ÎØ∏ÎîîÏñ¥ Ïª®ÌÖêÏ∏† Í∞ÄÏ†∏Ïò§Í∏∞ ÏãúÏûë...")

        // Î≥ëÎ†¨Î°ú Ïó¨Îü¨ ÏÜåÏä§ÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
        await withTaskGroup(of: [ServiceUpdate]?.self) { group in
            // X (Twitter) ÏΩòÌÖêÏ∏†
            group.addTask {
                await self.fetchXContent()
            }

            // Reddit ÏΩòÌÖêÏ∏†
            group.addTask {
                await self.fetchRedditContent()
            }

            // YouTube ÏΩòÌÖêÏ∏†
            group.addTask {
                await self.fetchYouTubeContent()
            }

            // Í≤∞Í≥º ÏàòÏßë
            var newUpdates: [ServiceUpdate] = []
            for await result in group {
                if let updates = result {
                    newUpdates.append(contentsOf: updates)
                }
            }

            // Í∏∞Ï°¥ ÏóÖÎç∞Ïù¥Ìä∏ÏôÄ Î≥ëÌï©
            // mergeUpdatesÍ∞Ä privateÏù¥ÎØÄÎ°ú ÏßÅÏ†ë Íµ¨ÌòÑ
            await MainActor.run {
                var merged = self.updates

                for update in newUpdates {
                    // ÎßÅÌÅ¨Î°ú Ï§ëÎ≥µ Ï≤¥ÌÅ¨
                    if !merged.contains(where: { $0.link == update.link }) {
                        merged.append(update)
                    }
                }

                // ÎÇ†ÏßúÏàú Ï†ïÎ†¨
                merged.sort { $0.publishedDate > $1.publishedDate }

                // ÏµúÎåÄ 100Í∞úÍπåÏßÄÎßå Ïú†ÏßÄ
                self.updates = Array(merged.prefix(100))

                // ÏùΩÏßÄ ÏïäÏùÄ ÏóÖÎç∞Ïù¥Ìä∏ ÌôïÏù∏
                self.hasUnreadUpdates = self.updates.contains { !$0.isRead }

                // Î°úÏª¨Ïóê Ï†ÄÏû•
                self.saveUpdates()
            }
        }
    }

    /// X (Twitter) ÏΩòÌÖêÏ∏† Í∞ÄÏ†∏Ïò§Í∏∞
    private func fetchXContent() async -> [ServiceUpdate]? {
        // TODO: X API Íµ¨ÌòÑ (API ÌÇ§ ÌïÑÏöî)
        // ÏûÑÏãú ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞
        return [
            ServiceUpdate(
                service: "X",
                serviceIcon: "üê¶",
                title: "OpenAI DevDay 2025 Î∞úÌëú",
                summary: "GPT-5 ÌîÑÎ¶¨Î∑∞ÏôÄ ÏÉàÎ°úÏö¥ API Í∏∞Îä•Ïù¥ Í≥µÍ∞úÎêòÏóàÏäµÎãàÎã§.",
                link: "https://x.com/openai",
                publishedDate: Date().addingTimeInterval(-3600),
                category: .newFeature,
                importance: .critical,
                isRead: false
            )
        ]
    }

    /// Reddit ÏΩòÌÖêÏ∏† Í∞ÄÏ†∏Ïò§Í∏∞
    private func fetchRedditContent() async -> [ServiceUpdate]? {
        // Ïã§Ï†ú Reddit RSS ÌååÏã±ÏùÑ ÏúÑÌï¥ parseRSSFeed Í∏∞Îä• Î≥µÏÇ¨
        let additionalSubreddits = [
            RSSSource(name: "Reddit AI", icon: "ü§ñ", url: "https://www.reddit.com/r/artificial/.rss", category: "AI Ïª§ÎÆ§ÎãàÌã∞"),
            RSSSource(name: "Reddit OpenAI", icon: "ü§ñ", url: "https://www.reddit.com/r/OpenAI/.rss", category: "AI Ïª§ÎÆ§ÎãàÌã∞"),
            RSSSource(name: "Reddit LocalLLaMA", icon: "ü§ñ", url: "https://www.reddit.com/r/LocalLLaMA/.rss", category: "AI Ïª§ÎÆ§ÎãàÌã∞")
        ]

        var redditUpdates: [ServiceUpdate] = []

        for source in additionalSubreddits {
            // parseRSSFeedÍ∞Ä privateÏù¥ÎØÄÎ°ú ÏßÅÏ†ë Íµ¨ÌòÑ
            guard let url = URL(string: source.url) else { continue }

            do {
                let (data, _) = try await URLSession.shared.data(from: url)
                let parser = SimpleRSSParser()
                let items = parser.parse(data: data)

                let updates = items.prefix(5).map { item in
                    ServiceUpdate(
                        service: source.name,
                        serviceIcon: source.icon,
                        title: item.title,
                        summary: self.cleanHTML(item.description),
                        link: item.link,
                        publishedDate: item.pubDate ?? Date(),
                        category: self.categorizeUpdate(item.title),
                        importance: .normal,
                        isRead: false
                    )
                }

                redditUpdates.append(contentsOf: updates)
            } catch {
                print("RSS ÌååÏã± ÏóêÎü¨ (\(source.name)): \(error)")
            }
        }

        return redditUpdates
    }

    /// YouTube ÏΩòÌÖêÏ∏† Í∞ÄÏ†∏Ïò§Í∏∞
    private func fetchYouTubeContent() async -> [ServiceUpdate]? {
        // TODO: YouTube Data API Íµ¨ÌòÑ (API ÌÇ§ ÌïÑÏöî)
        // ÏûÑÏãú ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞
        return [
            ServiceUpdate(
                service: "YouTube",
                serviceIcon: "üì∫",
                title: "Two Minute Papers: ÏÉàÎ°úÏö¥ AI ÎÖºÎ¨∏ Î¶¨Î∑∞",
                summary: "ÏµúÏã† Diffusion Î™®Îç∏ Í∞úÏÑ† ÎÖºÎ¨∏ÏùÑ Îã§Î£πÎãàÎã§.",
                link: "https://youtube.com",
                publishedDate: Date().addingTimeInterval(-7200),
                category: .general,
                importance: .normal,
                isRead: false
            )
        ]
    }

    // MARK: - Helper Methods (SimpleFeedManagerÏóêÏÑú privateÏúºÎ°ú ÏÑ†Ïñ∏Îêú Î©îÏÑúÎìúÎì§)

    private func cleanHTML(_ html: String) -> String {
        let pattern = "<[^>]+>"
        let cleaned = html.replacingOccurrences(
            of: pattern,
            with: "",
            options: .regularExpression
        )
        return String(cleaned.prefix(200))
    }

    private func categorizeUpdate(_ title: String) -> ServiceUpdate.UpdateCategory {
        let lower = title.lowercased()

        if lower.contains("price") || lower.contains("pricing") {
            return .priceChange
        } else if lower.contains("api") {
            return .apiUpdate
        } else if lower.contains("model") || lower.contains("gpt") {
            return .modelUpdate
        } else if lower.contains("feature") || lower.contains("update") {
            return .newFeature
        }

        return .general
    }

    private func saveUpdates() {
        if let encoded = try? JSONEncoder().encode(updates) {
            UserDefaults.standard.set(encoded, forKey: "SimpleFeedUpdates")
        }
    }

    // MARK: - ÌÜµÍ≥Ñ Í∏∞Îä•

    /// ÏÑúÎπÑÏä§Î≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïàò
    func updateCountByService() -> [String: Int] {
        let grouped = Dictionary(grouping: updates) { $0.service }
        return grouped.mapValues { $0.count }
    }

    /// Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïàò
    func updateCountByCategory() -> [ServiceUpdate.UpdateCategory: Int] {
        let grouped = Dictionary(grouping: updates) { $0.category }
        return grouped.mapValues { $0.count }
    }

    /// Ïò§ÎäòÏùò ÏóÖÎç∞Ïù¥Ìä∏
    func todayUpdates() -> [ServiceUpdate] {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())

        return updates.filter { update in
            calendar.isDate(update.publishedDate, inSameDayAs: today)
        }
    }

    /// Ïù¥Î≤à Ï£º ÏóÖÎç∞Ïù¥Ìä∏
    func thisWeekUpdates() -> [ServiceUpdate] {
        let calendar = Calendar.current
        guard let weekAgo = calendar.date(byAdding: .day, value: -7, to: Date()) else {
            return []
        }

        return updates.filter { update in
            update.publishedDate >= weekAgo
        }
    }

    // MARK: - Í≤ÄÏÉâ Í∏∞Îä•

    /// ÌÖçÏä§Ìä∏ Í≤ÄÏÉâ
    func searchUpdates(query: String) -> [ServiceUpdate] {
        let lowercasedQuery = query.lowercased()

        return updates.filter { update in
            update.title.lowercased().contains(lowercasedQuery) ||
            update.summary.lowercased().contains(lowercasedQuery) ||
            update.service.lowercased().contains(lowercasedQuery)
        }
    }

    // MARK: - ÏïåÎ¶º Í∏∞Îä•

    /// Ï§ëÏöî ÏóÖÎç∞Ïù¥Ìä∏ ÏïåÎ¶º
    func checkForCriticalUpdates() {
        let criticalUnread = updates.filter {
            $0.importance == .critical && !$0.isRead
        }

        if !criticalUnread.isEmpty {
            // Î°úÏª¨ ÏïåÎ¶º Î∞úÏÜ°
            sendLocalNotification(
                title: "Ï§ëÏöî AI ÏóÖÎç∞Ïù¥Ìä∏",
                body: "\(criticalUnread.count)Í∞úÏùò Ï§ëÏöîÌïú ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä ÏûàÏäµÎãàÎã§.",
                badge: criticalUnread.count
            )
        }
    }

    private func sendLocalNotification(title: String, body: String, badge: Int) {
        let content = UNMutableNotificationContent()
        content.title = title
        content.body = body
        content.badge = NSNumber(value: badge)
        content.sound = .default

        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
        let request = UNNotificationRequest(
            identifier: "ai-update-\(UUID().uuidString)",
            content: content,
            trigger: trigger
        )

        UNUserNotificationCenter.current().add(request)
    }
}

// MARK: - Ï∂îÍ∞Ä Îç∞Ïù¥ÌÑ∞ Î™®Îç∏
extension SimpleFeedManager {
    /// ÌîºÎìú ÏÜåÏä§ ÌÉÄÏûÖ
    enum FeedSourceType: String, CaseIterable {
        case rss = "RSS"
        case twitter = "X"
        case reddit = "Reddit"
        case youtube = "YouTube"
        case manual = "Manual"

        var icon: String {
            switch self {
            case .rss: return "üì°"
            case .twitter: return "üê¶"
            case .reddit: return "ü§ñ"
            case .youtube: return "üì∫"
            case .manual: return "‚úèÔ∏è"
            }
        }
    }

    /// ÌîºÎìú ÌÜµÍ≥Ñ
    struct FeedStatistics {
        let totalUpdates: Int
        let unreadCount: Int
        let todayCount: Int
        let criticalCount: Int
        let byService: [String: Int]
        let byCategory: [ServiceUpdate.UpdateCategory: Int]
    }

    /// ÌòÑÏû¨ ÌîºÎìú ÌÜµÍ≥Ñ Í∞ÄÏ†∏Ïò§Í∏∞
    func getStatistics() -> FeedStatistics {
        FeedStatistics(
            totalUpdates: updates.count,
            unreadCount: unreadUpdates().count,
            todayCount: todayUpdates().count,
            criticalCount: updates.filter { $0.importance == .critical }.count,
            byService: updateCountByService(),
            byCategory: updateCountByCategory()
        )
    }
}
